---
title: "GELECTION"
author: "Jessica McGreevy"
date: "2025-10-29"
output: html_document
---

```{r }
library(readr)
library(igraph)
library(tidyverse)
```



```{r}
GElection <- read_csv("C:\\Users\\lilly\\Documents\\GELECTION-DONEGAL.csv")
 
glimpse(GElection)
```


```{r}
nodes <- GElection %>%
  select(`Candidate Id`, `Candidate First Name`, `Candidate surname`) %>%
  distinct() %>% #Remove any duplicate rows
  mutate(name = paste(`Candidate First Name`, `Candidate surname`))

write_csv(nodes, "C:\\Users\\lilly\\Downloads\\GElection_nodes.csv")
```

```{r}
# Create events (candidates eliminated or elected)
# Event_Count = the count where the elimination/election happened.
# Event_Count_next = the following count, when the transfers actually occur.
events <- GElection %>%
  filter(Result %in% c("Excluded", "Elected")) %>%
  mutate(Event_Count = as.numeric(`Occurred On Count`),
         Event_Count_next = Event_Count + 1) %>%
  select(Source = `Candidate Id`, Event_Count, Event_Count_next)

# Create recipients (who received transfers)
# Keep only the relevant columns, and rename Candidate Id to "Source"
# to show the origin of transferred votes.
recipients <- GElection %>%
  filter(Transfers > 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Target = `Candidate Id`, Count_Number, Transfers)

# Create edges
# This joins each candidate who received transfers
 # to the candidate whose elimination/election caused those transfers.
edges <- recipients %>%
  inner_join(events, by = join_by(Count_Number == Event_Count_next), 
             relationship = "many-to-many") %>%
  filter(!is.na(Source)) %>%
  #weights to recsle
  #Group by source and target candidates to combine transfers between the same pair
  group_by(Source, Target) %>%
  summarise(Transfers = sum(Transfers, na.rm = TRUE), .groups = "drop") %>%
  #Rename columns to standard edge format used by igraph:
  # "from" = the candidate who transferred votes
  # "to"   = the candidate who received votes
  select(from = Source, to = Target, Transfers)

write_csv(edges, "C:\\Users\\lilly\\Downloads\\GElection_edges.csv")
```

```{r}
library(igraph)
nodes <- read_csv("C:\\Users\\lilly\\Downloads\\GElection_nodes.csv")
edges <- read_csv("C:\\Users\\lilly\\Downloads\\GElection_edges.csv")

g <- graph_from_data_frame(d = edges, directed = TRUE, vertices = nodes)
# Each candidate is a vertex (node)
# Each transfer is an edge (directed arrow)
# The graph 'g' can now be analyzed or visualized with ggraph or igraph packages
vcount(g)  
ecount(g)
```

```{r}
library(ggraph)

ggraph(g, layout = "fr") + #this mode less overlapping
  geom_edge_link(
    aes(width = Transfers),
    arrow = arrow(length = unit(3, 'mm'), type = "closed"),  # # larger, more visible arrowheads
    end_cap = circle(4, 'mm'),
    edge_colour = "grey40",
    alpha = 0.8
  ) +
  geom_node_point(size = 10, color = "skyblue") +
  geom_node_text(aes(label = name), vjust = 1.5, size = 3.5) +
  theme_void()
```

```{r}
#better graph
library(ggraph)
nodes <- GElection %>%
 group_by(`Candidate Id`) %>%
  # Get the final status of candidate
  mutate(Status = ifelse(any(Result == "Elected", na.rm = TRUE), "Elected",
                  ifelse(any(Result == "Excluded", na.rm = TRUE), "Excluded", 
                         "Not Elected/Excluded"))) %>%
  distinct(`Candidate Id`, `Candidate First Name`, `Candidate surname`, Status) %>%
  mutate(name = `Candidate Id`)
g <- graph_from_data_frame(edges, vertices = nodes, directed = TRUE)
ggraph(g, layout = "fr") +
  # Edges (vote transfers)
  geom_edge_link(
    aes(width = Transfers, alpha = Transfers),
    colour = "grey50",
    arrow = arrow(length = unit(4, 'mm'), type = "closed"),
    end_cap = circle(3, 'mm'),
    lineend = "round"
  ) +
  
 geom_node_point(aes(color = Status), size = 6, alpha = 0.8) +
  scale_color_manual(values = c("Elected" = "darkgreen", 
                                 "Excluded" = "red")) +
  
  # Labels (candidate names)
  geom_node_text(
    aes(label = paste(`Candidate First Name`, `Candidate surname`)),
    repel = TRUE,    #  repel overlapping labels
    size = 3.5,
    fontface = "bold",
    color = "black"
  ) +
  
  #  Legend and theme
  scale_edge_width(range = c(0.2, 2)) +
  scale_edge_alpha(range = c(0.3, 0.9)) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Vote Transfer Network 2020 – Donegal General Election") 
```



```{r}   
#Worried non-transfered were included in the graph
# What left in each count (negative transfers from eliminated/elected)
votes_leaving <- GElection %>%
  filter(Transfers < 0) %>%   
  group_by(`Count Number`) %>%
  summarise(
    Total_Left = abs(sum(Transfers, na.rm = TRUE)), # sum of negative transfers (absolute value)
    Who_Left = paste(unique(paste(`Candidate First Name`, `Candidate surname`)), collapse = ", ")
  )

# What arrived in each count (positive transfers)
votes_arriving <- GElection %>%
  filter(Transfers > 0) %>%   # keep rows where votes increased
  group_by(`Count Number`) %>%
  summarise(
    Total_Arrived = sum(Transfers, na.rm = TRUE)
  )

# Compare
flow_comparison <- votes_leaving %>%
  left_join(votes_arriving, by = "Count Number") %>%  #joins the table
  mutate(
    Non_Transferable = Total_Left - Total_Arrived   # looks at the difference
  ) %>%
  arrange(`Count Number`)

print(flow_comparison)

# Total non-transferable
total_nt <- sum(flow_comparison$Non_Transferable, na.rm = TRUE)  
print(paste("Total non-transferable:", total_nt))
```
```{r}
#proportion of transfers/all transfers 139/941 1 or 2  per round 4th count election fraud maths models no of non-transfrables all c
# 1. Sum all positive transfers in the raw data (what arrived)
total_arrived <- GElection %>%
  filter(Transfers > 0) %>%
  summarise(Total = sum(Transfers, na.rm = TRUE))

print(paste("Total arrived (raw data):", total_arrived$Total))

# 2. Sum all transfers in your graph edges
total_in_graph <- sum(edges$Transfers, na.rm = TRUE)
print(paste("Total in graph:", total_in_graph))
```

```{r}
 #realised there was duplicates in the count values
g <- graph_from_data_frame(edges, vertices = nodes, directed = TRUE)
g_filtered <- delete_edges(g, which(E(g)$Transfers < 500))

plot(g_filtered,
     vertex.label = V(g_filtered)$name,
     vertex.color = ifelse(V(g_filtered)$Status == "Elected", "darkgreen",
                    ifelse(V(g_filtered)$Status == "Excluded", "red", "grey60")),
     vertex.size = 8,
     edge.label = E(g_filtered)$Transfers,
     edge.label.cex = 0.7,
     edge.arrow.size = 0.5,
     main = "Donegal GE 2024 - Vote Transfers")
plot(g,
     vertex.label = V(g)$name,
     vertex.color = ifelse(V(g)$Status == "Elected", "darkgreen",
                    ifelse(V(g)$Status == "Excluded", "red", "grey60")),
     vertex.size = 8,
     edge.label = E(g)$Transfers,
     edge.label.cex = 0.7,
     edge.arrow.size = 0.5,
     main = "Donegal GE 2024 - Vote Transfers")
```

```{r}
# Sum all transfers in your edges
total_transfers <- sum(edges$Transfers, na.rm = TRUE)
print(paste("Total transfers in graph:", total_transfers))

# Also check if any are negative
negative_transfers <- edges %>% filter(Transfers < 0)
print(paste("Number of negative transfers:", nrow(negative_transfers)))

```

```{r}
# Get transfers with count information
all_transfers <- recipients %>%
  left_join(events, by = join_by(Count_Number == Event_Count_next), 
            relationship = "many-to-many") %>%
  filter(!is.na(Source)) %>%
  left_join(
    nodes %>% select(from = `Candidate Id`, 
                     From_FirstName = `Candidate First Name`,
                     From_Surname = `Candidate surname`),
    by = c("Source" = "from")
  ) %>%
  left_join(
    nodes %>% select(to = `Candidate Id`, 
                     To_FirstName = `Candidate First Name`,
                     To_Surname = `Candidate surname`),
    by = c("Target" = "to")
  ) %>%
  mutate(From = paste(From_FirstName, From_Surname),
         To = paste(To_FirstName, To_Surname)) %>%
  select(Count_Number, From, To, Transfers) %>%
  arrange(Count_Number, desc(Transfers))

# View all
print(all_transfers, n = Inf)

```

 
 
```{r}
 # Check Pearse Doherty specifically
GElection %>%
  filter(`Candidate First Name` == "Pearse", `Candidate surname` == "Doherty") %>%
  select(`Count Number`, Result, `Occurred On Count`, Transfers, `Total Votes`) %>%
  arrange(`Count Number`) %>%
  print()

# When did he actually LOSE votes (negative transfer)?
GElection %>%
  filter(`Candidate First Name` == "Pearse", `Candidate surname` == "Doherty",
         Transfers < 0) %>%
  select(`Count Number`, Transfers, Result, `Occurred On Count`) %>%
  print()
```
 

```{r}
# Create events based on negative transfers (not Occurred On Count)
events <- GElection %>%
  filter(Transfers < 0) %>%
  mutate(Event_Count = as.numeric(`Count Number`),
         Event_Count_next = Event_Count + 1,
         Votes_Lost = abs(Transfers)) %>%
  select(Source = `Candidate Id`, Event_Count, Event_Count_next, Votes_Lost)

# Create recipients
recipients <- GElection %>%
  filter(Transfers > 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Target = `Candidate Id`, Count_Number, Transfers)

# Create edges with proportional allocation
edges <- recipients %>%
  inner_join(events, by = join_by(Count_Number == Event_Count_next), 
             relationship = "many-to-many") %>%
  filter(!is.na(Source)) %>%
  # KEY: Allocate proportionally based on how much each source lost
  group_by(Count_Number, Target) %>%
  mutate(
    Total_Available = sum(Votes_Lost),
    Proportion = Votes_Lost / Total_Available,
    Allocated_Transfers = Transfers * Proportion
  ) %>%
  ungroup() %>%
  select(from = Source, to = Target, Transfers = Allocated_Transfers) %>%
  group_by(from, to) %>%
  summarise(Transfers = sum(Transfers, na.rm = TRUE), .groups = "drop")

sum(edges$Transfers)
write_csv(edges, "C:/Users/lilly/Downloads/GElection_edges.csv")
# 16,217 because Count 2 (8,135 votes) has no Count 1 negative transfers to match to.
#To get the full 24,352, we need to handle Count 2 separately. Since we know Count 2 transfers came from Count 1 elected candidates (Pearse Doherty's surplus) add in
```

```{r}
# Main edges (Counts 3-9) - based on negative transfers
edges_main <- recipients %>%
  filter(Count_Number > 2) %>%  # Skip Count 2 for now
  inner_join(events, by = join_by(Count_Number == Event_Count_next), 
             relationship = "many-to-many") %>%
  filter(!is.na(Source)) %>%
  group_by(Count_Number, Target) %>%
  mutate(
    Total_Available = sum(Votes_Lost),
    Proportion = Votes_Lost / Total_Available,
    Allocated_Transfers = Transfers * Proportion
  ) %>%
  ungroup() %>%
  select(from = Source, to = Target, Transfers = Allocated_Transfers)

# Count 2 edges - from Count 1 elected candidates
count1_elected <- GElection %>%
  filter(`Count Number` == 1, Result == "Elected") %>%
  pull(`Candidate Id`)

# Find who had negative transfers at Count 2 (surplus distribution)
count2_sources <- GElection %>%
  filter(`Count Number` == 2, Transfers < 0) %>%
  select(from = `Candidate Id`, Votes_Lost = Transfers) %>%
  mutate(Votes_Lost = abs(Votes_Lost))

edges_count2 <- recipients %>%
  filter(Count_Number == 2) %>%
  cross_join(count2_sources) %>%
  group_by(Target) %>%
  mutate(
    Total_Available = sum(Votes_Lost),
    Proportion = Votes_Lost / Total_Available,
    Allocated_Transfers = Transfers * Proportion
  ) %>%
  ungroup() %>%
  select(from, to = Target, Transfers = Allocated_Transfers)

# Combine
edges_complete <- bind_rows(edges_main, edges_count2) %>%
  group_by(from, to) %>%
  summarise(Transfers = sum(Transfers), .groups = "drop")

sum(edges_complete$Transfers)
```
```{r}
#better graph
library(ggraph)
nodes <- GElection %>%
 group_by(`Candidate Id`) %>%
  # Get the final status of candidate
  mutate(Status = ifelse(any(Result == "Elected", na.rm = TRUE), "Elected",
                  ifelse(any(Result == "Excluded", na.rm = TRUE), "Excluded", 
                         "Not Elected/Excluded"))) %>%
  distinct(`Candidate Id`, `Candidate First Name`, `Candidate surname`, Status) %>%
  mutate(name = `Candidate Id`)
g <- graph_from_data_frame(edges_complete, vertices = nodes, directed = TRUE)
ggraph(g, layout = "fr") +
  # Edges (vote transfers)
  geom_edge_link(
    aes(width = Transfers, alpha = Transfers),
    colour = "grey50",
    arrow = arrow(length = unit(4, 'mm'), type = "closed"),
    end_cap = circle(3, 'mm'),
    lineend = "round"
  ) +
  
 geom_node_point(aes(color = Status), size = 6, alpha = 0.8) +
  scale_color_manual(values = c("Elected" = "darkgreen", 
                                 "Excluded" = "red")) +
  
  # Labels (candidate names)
  geom_node_text(
    aes(label = paste(`Candidate First Name`, `Candidate surname`)),
    repel = TRUE,    #  repel overlapping labels
    size = 3.5,
    fontface = "bold",
    color = "black"
  ) +
  
  #  Legend and theme
  scale_edge_width(range = c(0.2, 2)) +
  scale_edge_alpha(range = c(0.3, 0.9)) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Vote Transfer Network 2020 – Donegal General Election") 
```

```{r}
#looks at the communties before transfering
library(igraph)
 
g <- graph_from_data_frame(edges_complete, vertices = nodes, directed = TRUE)
g_undir <- as.undirected(g, mode = "collapse", edge.attr.comb = "sum")


# 1. Walktrap (undirected)
wt <- cluster_walktrap(g_undir)
cat("1. WALKTRAP\n")
cat("Communities:", length(wt), "\n")
cat("Modularity:", modularity(wt), "\n")
print(membership(wt))
cat("\n")

# 2. Infomap (directed - best for flow networks)
im <- cluster_infomap(g)
cat("2. INFOMAP\n")
cat("Communities:", length(im), "\n")
print(membership(im))
cat("\n")

# 3. Louvain (undirected)
lv <- cluster_louvain(g_undir)
cat("3. LOUVAIN\n")
cat("Communities:", length(lv), "\n")
cat("Modularity:", modularity(lv), "\n")
print(membership(lv))
cat("\n")

# Visualize  
plot(lv, g,
     vertex.label = paste(V(g)$`Candidate First Name`, 
                          V(g)$`Candidate surname`),
     vertex.size = 8,
     main = "Donegal Communities")
```

```{r}
#investigate weighting transfers by first count 
candidate_totals <- GElection %>%
  group_by(`Candidate Id`) %>%
  summarise(
    # Use Count 1 votes as baseline
    count1_votes = `Total Votes`[`Count Number` == "1"][1]
  ) %>%
  filter(!is.na(count1_votes))

cat("Candidates with Count 1 votes:\n")
print(candidate_totals)
```

```{r}
#normalised graphs by tranfers/the total votes from count 1, not as informative did /transfers after instead
edges_normalised <- edges_complete %>%
  left_join(candidate_totals, by = c("to" = "Candidate Id")) %>%
  rename(to_total_votes = count1_votes) %>%
  mutate(
    # Avoid dividing by zero 
    proportion_of_recipient = ifelse(!is.na(to_total_votes) & to_total_votes > 0,
                                     Transfers / to_total_votes,
                                     0),
    # Store this as graph weight
    weight = proportion_of_recipient
  )
g_norm <- graph_from_data_frame(
  d = edges_normalised,
  vertices = nodes,
  directed = TRUE
)
# Also make an undirected graph
g_norm_undirected <- as.undirected(g_norm, mode = "collapse")
glimpse(edges_normalised)

```
```{r}
#normalised graph
plot(g_norm,
     vertex.label = paste(V(g_norm)$`Candidate First Name`, 
                          V(g_norm)$`Candidate surname`),
     vertex.color = ifelse(V(g_norm)$Status == "Elected", "darkgreen",
                    ifelse(V(g_norm)$Status == "Excluded", "red", "grey60")),
     vertex.size = 8,
     edge.width = E(g_norm)$weight ,       #normalised weights
     edge.label = round(E(g_norm)$weight, 3),  # show proportional weight (rounded)
     edge.label.cex = 0.7,
     edge.arrow.size = 0.4,
     main = "Donegal GE 2024 – Normalised Transfer Network by proportion of transfers" 
)
```
```{r}
g_norm_filtered <- delete_edges(g_norm, which(E(g_norm)$weight < 0.05))
plot(g_norm_filtered,
     vertex.label = paste(V(g_norm_filtered)$`Candidate First Name`,
                          V(g_norm_filtered)$`Candidate surname`),
     vertex.color = ifelse(V(g_norm_filtered)$Status == "Elected", "darkgreen",
                           ifelse(V(g_norm_filtered)$Status == "Excluded", "red", "grey60")),
     vertex.size = 8,
     edge.width = E(g_norm_filtered)$weight , 
     edge.label = round(E(g_norm_filtered)$weight, 3),
     edge.label.cex = 0.7,
     edge.arrow.size = 0.4,
     main = "Donegal GE 2024 – Filtered Normalised Transfer Network")
```

```{r}
library(igraph)
 
g_norm <- graph_from_data_frame(
  d = edges_normalised,
  vertices = nodes,
  directed = TRUE)
g_norm_undirected <- as.undirected(g_norm, mode = "collapse")


# 1. Walktrap (undirected)
wt <- cluster_walktrap(g_norm_undirected)
cat("1. WALKTRAP\n")
cat("Communities:", length(wt), "\n")
cat("Modularity:", modularity(wt), "\n")
print(membership(wt))
cat("\n")

# 2. Infomap (directed - best for flow networks)
im <- cluster_infomap(g_norm)
cat("2. INFOMAP\n")
cat("Communities:", length(im), "\n")
print(membership(im))
cat("\n")

# 3. Louvain (undirected)
lv <- cluster_louvain(g_norm_undirected)
cat("3. LOUVAIN\n")
cat("Communities:", length(lv), "\n")
cat("Modularity:", modularity(lv), "\n")
print(membership(lv))
cat("\n")

# Visualize  
plot(lv, g,
     vertex.label = paste(V(g_norm)$`Candidate First Name`, 
                          V(g_norm)$`Candidate surname`),
     vertex.size = 8,
     main = "Donegal Communities")
```
```{r}
#This is with differnt weighting instead of with the first count weighted by recipients transfers
recipient_totals <- edges_complete %>%
  group_by(to) %>%
  summarise(
    total_received = sum(Transfers, na.rm = TRUE),
    n_senders = n()  # How many candidates transferred to this one
  )
edges_normalised_recipient <- edges_complete %>%
  left_join(recipient_totals, by = "to") %>%
  mutate(
    # Proportion of this recipient's total that came from this sender
    proportion_of_recipient = ifelse(!is.na(total_received) & total_received > 0,
                                     Transfers / total_received,
                                     0),
    weight = proportion_of_recipient
  )
```

````{r}
g_recipient_directed <- edges_normalised_recipient %>%
  select(from, to, weight) %>%
  graph_from_data_frame(vertices = nodes, directed = TRUE)


g_recipient_undirected <- as.undirected(g_recipient_directed, mode = "collapse")


louvain_recipient <- cluster_louvain(g_recipient_undirected, 
                                     weights = E(g_recipient_undirected)$weight)

# Walktrap
walktrap_recipient <- cluster_walktrap(g_recipient_undirected, 
                                       weights = E(g_recipient_undirected)$weight, 
                                       steps = 4)

# Infomap (uses directed graph)
infomap_recipient <- cluster_infomap(g_recipient_directed, 
                                     e.weights = E(g_recipient_directed)$weight)
community_assignments <- nodes %>%
  mutate(
    louvain_community = membership(louvain_recipient)[match(`Candidate Id`, V(g_recipient_undirected)$name)],
    walktrap_community = membership(walktrap_recipient)[match(`Candidate Id`, V(g_recipient_undirected)$name)],
    infomap_community = membership(infomap_recipient)[match(`Candidate Id`, V(g_recipient_directed)$name)]
  )
louvain_summary <- community_assignments %>%
  group_by(louvain_community) %>%
  summarise(
    n_members = n(),
    members = paste(name, collapse = ", ")
  ) %>%
  arrange(desc(n_members))

print(louvain_summary)

walktrap_summary <- community_assignments %>%
  group_by(walktrap_community) %>%
  summarise(
    n_members = n(),
    members = paste(name, collapse = ", ")
  ) %>%
  arrange(desc(n_members))

print(walktrap_summary)

infomap_summary <- community_assignments %>%
  group_by(infomap_community) %>%
  summarise(
    n_members = n(),
    members = paste(name, collapse = ", ")
  ) %>%
  arrange(desc(n_members))

print(infomap_summary)

````

```{r}
plot(g_recipient_undirected,
     vertex.label = paste(V(g_norm)$`Candidate First Name`, 
                          V(g_norm)$`Candidate surname`),
     vertex.color = ifelse(V(g_norm)$Status == "Elected", "darkgreen",
                    ifelse(V(g_norm)$Status == "Excluded", "red", "grey60")),
     vertex.size = 8,
     edge.width = E(g_norm)$weight ,       #normalised weights
     edge.label = round(E(g_norm)$weight, 3),  # show proportional weight (rounded)
     edge.label.cex = 0.7,
     edge.arrow.size = 0.4,
     main = "Donegal GE 2024 – Normalised Transfer Network by recipent strength" )
     
plot(louvain_recipient, g_recipient_undirected,
     vertex.label = paste(V(g_recipient_undirected)$`Candidate First Name`, 
                          V(g_recipient_undirected)$`Candidate surname`),
     vertex.size = 8,
     vertex.label.cex = 0.7,
     edge.width = E(g_recipient_undirected)$weight ,
     main = "Donegal Communities (Louvain)")
```


```{r}
# Create graph
g <- graph_from_data_frame(edges, vertices = nodes, directed = TRUE)
g_filtered <- delete_edges(g, which(E(g)$Transfers < 100))

plot(g_filtered,
     vertex.label = paste(V(g_filtered)$`Candidate First Name`, 
                          V(g_filtered)$`Candidate surname`),
     vertex.color = ifelse(V(g_filtered)$Status == "Elected", "darkgreen",
                    ifelse(V(g_filtered)$Status == "Excluded", "red", "grey60")),
     vertex.size = 8,
     edge.label = E(g_filtered)$Transfers,
     edge.label.cex = 0.7,
     edge.arrow.size = 0.5,
     edge.width = E(g_filtered)$Transfers / 500,
     main = "Donegal GE 2024 - Complete Transfer Network")
```