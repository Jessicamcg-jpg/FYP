---
title: "Synethic"
author: "Jessica McGreevy"
date: "2025-11-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r }
library(readr)
library(igraph)
library(tidyverse)
```

## Including Plots

You can also embed plots, for example:









 


 









                  
                  

```{r}
Synthetic_NEW <- read_csv("C:\\Users\\lilly\\Documents\\Synethtic_3.csv")
 
Synthetic_NEW
```



```{r}
nodes <- Synthetic_NEW %>%
  select(`Candidate First Name`, `Candidate surname`) %>%
  distinct() %>% #Remove any duplicate rows
  mutate(name = paste(`Candidate First Name`, `Candidate surname`))

write_csv(nodes, "C:\\Users\\lilly\\Downloads\\Synethic_nodes_NEW.csv")
```

```{r}
#Worried non-transfered were included in the graph
# What left in each count (negative transfers from eliminated/elected)
votes_leaving <-Synthetic_NEW %>%
  filter(Transfers < 0) %>%   
  group_by(`Count Number`) %>%
  summarise(
    Total_Left = abs(sum(Transfers, na.rm = TRUE)), # sum of negative transfers (absolute value)
    Who_Left = paste(unique(paste(`Candidate First Name`, `Candidate surname`)), collapse = ", ")
  )

# What arrived in each count (positive transfers)
votes_arriving <- Synthetic_NEW %>%
  filter(Transfers > 0) %>%   # keep rows where votes increased
  group_by(`Count Number`) %>%
  summarise(
    Total_Arrived = sum(Transfers, na.rm = TRUE)
  )

# Compare
flow_comparison <- votes_leaving %>%
  left_join(votes_arriving, by = "Count Number") %>%  #joins the table
  mutate(
    Non_Transferable = Total_Left - Total_Arrived   # looks at the difference
  ) %>%
  arrange(`Count Number`)

print(flow_comparison)

# Total non-transferable
total_nt <- sum(flow_comparison$Non_Transferable, na.rm = TRUE)  
print(paste("Total non-transferable:", total_nt))
```
                  
                  
```{r}
# 1. Sum all positive transfers in the raw data (what arrived)
total_arrived <- Synthetic_NEW %>%
  filter(Transfers > 0) %>%
  summarise(Total = sum(Transfers, na.rm = TRUE))

print(paste("Total arrived (raw data):", total_arrived$Total))

# 2. Sum all transfers in your graph edges
total_in_graph <- sum(edges$Transfers, na.rm = TRUE)
print(paste("Total in graph:", total_in_graph))
```

```{r}
# Get negative transfers (sources)
sources <- Synthetic_NEW %>%
  filter(Transfers < 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Source = `Candidate Id`,
         Count_Number,
         Votes_Lost = Transfers) %>%
  mutate(Votes_Lost = abs(Votes_Lost))

# Get positive transfers (recipients)
recipients <- Synthetic_NEW %>%
  filter(Transfers > 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Target = `Candidate Id`,
         Count_Number,
         Transfers)

# Join on same Count Number
edges <- recipients %>%
  inner_join(sources, 
             by = "Count_Number",
             relationship = "many-to-many") %>%
  select(from = Source, to = Target, Transfers) %>%
  group_by(from, to) %>%
  summarise(Transfers = sum(Transfers, na.rm = TRUE), .groups = "drop")

sum(edges$Transfers)
write_csv(edges, "C:/Users/lilly/Downloads/Synthetic_edges.csv")
```

````{r}
# Create events based on negative transfers (not Occurred On Count)
events <- Synthetic_NEW %>%
  filter(Transfers < 0) %>%
  mutate(Event_Count = as.numeric(`Count Number`),
         Event_Count_next = Event_Count + 1,
         Votes_Lost = abs(Transfers)) %>%
  select(Source = `Candidate Id`, Event_Count, Event_Count_next, Votes_Lost)

# Create recipients
recipients <-Synthetic_NEW %>%
  filter(Transfers > 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Target = `Candidate Id`, Count_Number, Transfers)
 
edges <- recipients %>%
  inner_join(events, by = join_by(Count_Number == Event_Count_next), 
             relationship = "many-to-many") %>%
  filter(!is.na(Source)) %>%
   
  group_by(Count_Number, Target) %>%
  mutate(
    Total_Available = sum(Votes_Lost),
    Proportion = Votes_Lost / Total_Available,
    Allocated_Transfers = Transfers * Proportion
  ) %>%
  ungroup() %>%
  select(from = Source, to = Target, Transfers = Allocated_Transfers) %>%
  group_by(from, to) %>%
  summarise(Transfers = sum(Transfers, na.rm = TRUE), .groups = "drop")

sum(edges$Transfers)
write_csv(edges, "C:/Users/lilly/Downloads/Synethic_edges.csv")
 
#so counts 1 Anna came from the surplus voters 
````
 


```{r}
#better graph
library(ggraph)
nodes <- Synthetic_NEW %>%
 group_by(`Candidate Id`) %>%
  # Get the final status of candidate
  mutate(Status = ifelse(any(Result == "Elected", na.rm = TRUE), "Elected",
                  ifelse(any(Result == "Excluded", na.rm = TRUE), "Excluded", 
                         "Not Elected/Excluded"))) %>%
  distinct(`Candidate Id`, `Candidate First Name`, `Candidate surname`, Status) %>%
  mutate(name = `Candidate Id`)
g <- graph_from_data_frame(edges, vertices = nodes, directed = TRUE)
ggraph(g, layout = "fr") +
  # Edges (vote transfers)
  geom_edge_link(
    aes(width = Transfers, alpha = Transfers),
    colour = "grey50",
    arrow = arrow(length = unit(4, 'mm'), type = "closed"),
    end_cap = circle(3, 'mm'),
    lineend = "round"
  ) +
  
 geom_node_point(aes(color = Status), size = 6, alpha = 0.8) +
  scale_color_manual(values = c("Elected" = "darkgreen", 
                                 "Excluded" = "red")) +
  
  # Labels (candidate names)
  geom_node_text(
    aes(label = paste(`Candidate First Name`, `Candidate surname`)),
    repel = TRUE,    #  repel overlapping labels
    size = 3.5,
    fontface = "bold",
    color = "black"
  ) +
  
  #  Legend and theme
  scale_edge_width(range = c(0.2, 2)) +
  scale_edge_alpha(range = c(0.3, 0.9)) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Vote Transfer Network – General Election") 
```

```{r}
library(igraph)
 
g <- graph_from_data_frame(edges, vertices = nodes, directed = TRUE)
g_undir <- as.undirected(g, mode = "collapse", edge.attr.comb = "sum")

#  Infomap (directed best for flow networks)
im <- cluster_infomap(g)
cat("2. INFOMAP\n")
cat("Communities:", length(im), "\n")
print(membership(im))
cat("\n")

#  Louvain (undirected)
lv <- cluster_louvain(g_undir)
cat("3. LOUVAIN\n")
cat("Communities:", length(lv), "\n")
cat("Modularity:", modularity(lv), "\n")
print(membership(lv))
cat("\n")

# Visualize  
plot(lv, g_undir,
     vertex.label = paste(V(g)$`Candidate First Name` , 
                          V(g)$`Candidate surname`),
     vertex.size = 8,
     main = "Communities")
```
So this idealised scenario, now need add changes within atl east independents to see how much it changes modularity 

```{r}
Synthetic_Up <- read_csv("C:\\Users\\lilly\\Documents\\Synethtic_3.csv")
 
Synthetic_Up
```



```{r}
nodes_2 <- Synthetic_Up %>%
  select(`Candidate First Name`, `Candidate surname`) %>%
  distinct() %>% #Remove any duplicate rows
  mutate(name = paste(`Candidate First Name`, `Candidate surname`))

write_csv(nodes_2, "C:\\Users\\lilly\\Downloads\\Synethic_nodes_Up.csv")
```

```{r}
# Get negative transfers (losing)
sources <- Synthetic_Up %>%
  filter(Transfers < 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Source = `Candidate Id`,
         Count_Number,
         Votes_Lost = Transfers) %>%
  mutate(Votes_Lost = abs(Votes_Lost))

# Get positive transfers (recieving)
recipients <- Synthetic_Up %>%
  filter(Transfers > 0) %>%
  mutate(Count_Number = as.numeric(`Count Number`)) %>%
  select(Target = `Candidate Id`,
         Count_Number,
         Transfers)

# Join on same Count Number
edges_2 <- recipients %>%
  inner_join(sources, 
             by = "Count_Number",
             relationship = "many-to-many") %>%
  select(from = Source, to = Target, Transfers) %>%
  group_by(from, to) %>%
  summarise(Transfers = sum(Transfers, na.rm = TRUE), .groups = "drop")

sum(edges_2$Transfers)
write_csv(edges_2, "C:/Users/lilly/Downloads/Synthetic_edges_Up.csv")
```


```{r}
#better graph
library(ggraph)
nodes_2 <- Synthetic_Up %>%
 group_by(`Candidate Id`) %>%
  # Get the final status of candidate
  mutate(Status = ifelse(any(Result == "Elected", na.rm = TRUE), "Elected",
                  ifelse(any(Result == "Excluded", na.rm = TRUE), "Excluded", 
                         "Not Elected/Excluded"))) %>%
  distinct(`Candidate Id`, `Candidate First Name`, `Candidate surname`, Status) %>%
  mutate(name = `Candidate Id`)
g_2 <- graph_from_data_frame(edges_2, vertices = nodes_2, directed = TRUE)
ggraph(g_2, layout = "fr") +
  # Edges (vote transfers)
  geom_edge_link(
    aes(width = Transfers, alpha = Transfers),
    colour = "grey50",
    arrow = arrow(length = unit(4, 'mm'), type = "closed"),
    end_cap = circle(3, 'mm'),
    lineend = "round"
  ) +
  
 geom_node_point(aes(color = Status), size = 6, alpha = 0.8) +
  scale_color_manual(values = c("Elected" = "darkgreen", 
                                 "Excluded" = "red")) +
  
  # Labels (candidate names)
  geom_node_text(
    aes(label = paste(`Candidate First Name`, `Candidate surname`)),
    repel = TRUE,    #  repel overlapping labels
    size = 3.5,
    fontface = "bold",
    color = "black"
  ) +
  
  #  Legend and theme
  scale_edge_width(range = c(0.2, 2)) +
  scale_edge_alpha(range = c(0.3, 0.9)) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Vote Transfer Network – General Election") 
```


```{r}
print(colnames(nodes_2))
print(nodes_2)
```


```{r}
g_2 <- graph_from_data_frame(edges_2, vertices = nodes_2, directed = TRUE)
g_undir <- as.undirected(g_2, mode = "collapse", edge.attr.comb = "sum")

#  Infomap (directed best for flow networks)
im <- cluster_infomap(g_2)
cat("2. INFOMAP\n")
cat("Communities:", length(im), "\n")
print(membership(im))
cat("\n")

#  Louvain (undirected)
lv <- cluster_louvain(g_undir)
cat("3. LOUVAIN\n")
cat("Communities:", length(lv), "\n")
cat("Modularity:", modularity(lv), "\n")
print(membership(lv))
cat("\n")

# Visualize  
plot(lv, g_undir,
     vertex.label = paste(V(g_2)$`Candidate First Name` , 
                          V(g_2)$`Candidate surname`),
     vertex.size = 8,
     main = "Communities")
```
Cumalitive ballot postion graph 
```{r}
library(ggraph)


nodes_2 <- Synthetic_Up%>%
  group_by(`Candidate Id`) %>%
  mutate(Status = ifelse(any(Result == "Elected", na.rm = TRUE), "Elected",
                  ifelse(any(Result == "Excluded", na.rm = TRUE), "Excluded", 
                         "Not Elected/Excluded"))) %>%
  distinct(`Candidate Id`, `Candidate First Name`, `Candidate surname`, Status) %>%
  mutate(id = as.character(`Candidate Id`))

# Create edges with  weight including percentages
edges_weighted <- edges_2 %>%

  group_by(to) %>%
  mutate(
    total_received = sum(Transfers, na.rm = TRUE),
    proportion_of_recipient = Transfers / total_received
  ) %>%
  ungroup() %>%
  
  group_by(from) %>%
  mutate(
    total_sent = sum(Transfers, na.rm = TRUE),
    proportion_of_sender = Transfers / total_sent
  ) %>%
  ungroup() %>%
  # Add weights
  mutate(
    weight = Transfers,
    weight_normalised = Transfers / max(Transfers, na.rm = TRUE),
    from = as.character(from),
    to = as.character(to)
  )

# Create graph with all weight metrics
graph_w <- graph_from_data_frame(edges_weighted, 
                                 vertices = nodes_2, 
                                 directed = TRUE)

# Verify edge attributes are there
print("Edge attributes in graph:")
print(edge_attr_names(graph_w))

# Plot with ggraph
ggraph(graph_w, layout = "fr") +
  # Edges with your weight metrics
  geom_edge_link(
    aes(width = weight, alpha = weight, 
        label = paste0(round(proportion_of_sender * 100, 1), "%")),
    colour = "grey50",
    arrow = arrow(length = unit(4, 'mm'), type = "closed"),
    end_cap = circle(3, 'mm'),
    lineend = "round"
  ) +
  
  # Nodes colored by status
  geom_node_point(aes(color = Status), size = 6, alpha = 0.8) +
  scale_color_manual(values = c("Elected" = "darkgreen", 
                                 "Excluded" = "red",
                                 "Not Elected/Excluded" = "grey60")) +
  
  # Labels
  geom_node_text(
    aes(label = paste(`Candidate First Name`, `Candidate surname`)),
    repel = TRUE,
    size = 3.5,
    fontface = "bold",
    color = "black"
  ) +
  
  # Scale edges
  scale_edge_width(range = c(0.2, 2)) +
  scale_edge_alpha(range = c(0.3, 0.9)) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
  ) +
  ggtitle("Vote Transfer Network – Synthetic Election")

 
```
```{r}
 graph_w_undirected <- as.undirected(graph_w, mode = "collapse", 
                                    edge.attr.comb = "sum")

louvain_weighted <- cluster_louvain(graph_w_undirected, weights = E(graph_w_undirected)$proportion_of_sender)

# community membership to graph
V(graph_w)$community <- membership(louvain_weighted)

plot(louvain_weighted, graph_w,
     vertex.label = paste(V(graph_w_undirected)$`Candidate First Name`, 
                          V(graph_w_undirected)$`Candidate surname`),
     vertex.size = 5,
     vertex.label.cex = 0.7,
     edge.width = E(graph_w)$weight / 500,  # Scale down the absolute transfers
     edge.arrow.size = 0.4,
     main = "Synthetic Election Communities (Louvain weighted )")

# Print results
cat("Community Membership:\n")
print(louvain_weighted$membership)
cat("\nModularity:", modularity(louvain_weighted), "\n\n")

 
```
```{r}
# Community membership for each candidate
cat("--- Community Membership ---\n")
community_summary <- data.frame(
  Candidate_ID = V(graph_w_undirected)$id,
  Candidate = paste(V(graph_w_undirected)$`Candidate First Name`, 
                   V(graph_w_undirected)$`Candidate surname`),
   Community = as.vector(membership(louvain_weighted)),  # Convert to vector
  Status = V(graph_w_undirected)$Status
) %>%
  arrange(Community, Candidate)

print(community_summary)
```


